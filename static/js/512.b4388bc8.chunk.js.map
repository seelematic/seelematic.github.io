{"version":3,"file":"static/js/512.b4388bc8.chunk.js","mappings":"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","sources":["worker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\r\n// In the worker, 'self' refers to the global scope.\r\nself.onmessage = function(e) {\r\n  const {\r\n    type,\r\n    data, // ArrayBuffer for the image data (Uint8ClampedArray)\r\n    width,\r\n    height,\r\n    originalBuffer,\r\n    blurredBuffer,\r\n    adjustedPolygon,\r\n    polygonB,\r\n    numPixelsSimulatedBlur,\r\n    totalBlurBlend\r\n  } = e.data;\r\n  \r\n  if (type === 'processBlur') {\r\n    // Reconstruct the typed arrays from the transferred buffers.\r\n    let imageDataArray = new Uint8ClampedArray(data);\r\n    const originalData = new Uint8ClampedArray(originalBuffer);\r\n    const blurredData = new Uint8ClampedArray(blurredBuffer);\r\n    \r\n    // Helper: compute distance from point p to line segment vw.\r\n    function distanceToSegment(p, v, w) {\r\n      const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;\r\n      if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);\r\n      let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\r\n      t = Math.max(0, Math.min(1, t));\r\n      const projection = {\r\n        x: v.x + t * (w.x - v.x),\r\n        y: v.y + t * (w.y - v.y)\r\n      };\r\n      return Math.hypot(p.x - projection.x, p.y - projection.y);\r\n    }\r\n    \r\n    // Helper: standard point-in-polygon test; if not inside, check if within a buffer distance from any edge.\r\n    function pointInPolygonWithBuffer(x, y, polygon, buffer = 2) {\r\n      let inside = false;\r\n      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n        const xi = polygon[i].x, yi = polygon[i].y;\r\n        const xj = polygon[j].x, yj = polygon[j].y;\r\n        if ((yi > y) !== (yj > y) &&\r\n            (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\r\n          inside = !inside;\r\n        }\r\n      }\r\n      if (inside) return true;\r\n      for (let i = 0; i < polygon.length; i++) {\r\n        const v = polygon[i];\r\n        const w = polygon[(i + 1) % polygon.length];\r\n        const d = distanceToSegment({ x, y }, v, w);\r\n        if (d <= buffer) return true;\r\n      }\r\n      return false;\r\n    }\r\n    \r\n    // The heavy nested loop doing per-pixel blending.\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        if (\r\n          pointInPolygonWithBuffer(x, y, adjustedPolygon, numPixelsSimulatedBlur * 3) ||\r\n          pointInPolygonWithBuffer(x, y, polygonB, numPixelsSimulatedBlur * 3)\r\n        ) {\r\n          const p = { x, y };\r\n          let minDistance = Infinity;\r\n          // Check distance to each edge in adjustedPolygon.\r\n          for (let i = 0; i < adjustedPolygon.length; i++) {\r\n            const v = adjustedPolygon[i];\r\n            const w = adjustedPolygon[(i + 1) % adjustedPolygon.length];\r\n            const d = distanceToSegment(p, v, w);\r\n            if (d < minDistance) minDistance = d;\r\n          }\r\n          // Check distance to each edge in polygonB.\r\n          for (let i = 0; i < polygonB.length; i++) {\r\n            const v = polygonB[i];\r\n            const w = polygonB[(i + 1) % polygonB.length];\r\n            const d = distanceToSegment(p, v, w);\r\n            if (d < minDistance) minDistance = d;\r\n          }\r\n          const sigma = numPixelsSimulatedBlur;\r\n          const weight = Math.exp(- (minDistance * minDistance) / (2 * sigma * sigma)) * totalBlurBlend;\r\n          const idx = (y * width + x) * 4;\r\n          imageDataArray[idx]     = weight * blurredData[idx]     + (1 - weight) * originalData[idx];\r\n          imageDataArray[idx + 1] = weight * blurredData[idx + 1] + (1 - weight) * originalData[idx + 1];\r\n          imageDataArray[idx + 2] = weight * blurredData[idx + 2] + (1 - weight) * originalData[idx + 2];\r\n          imageDataArray[idx + 3] = weight * blurredData[idx + 3] + (1 - weight) * originalData[idx + 3];\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Send back the modified image data buffer.\r\n    postMessage({ modifiedBuffer: imageDataArray.buffer }, [imageDataArray.buffer]);\r\n  }\r\n}; "],"names":["self","onmessage","e","type","data","width","height","originalBuffer","blurredBuffer","adjustedPolygon","polygonB","numPixelsSimulatedBlur","totalBlurBlend","imageDataArray","Uint8ClampedArray","originalData","blurredData","distanceToSegment","p","v","w","l2","x","y","Math","hypot","t","max","min","projection","pointInPolygonWithBuffer","polygon","buffer","arguments","length","undefined","inside","i","j","xi","yi","xj","yj","minDistance","Infinity","d","sigma","weight","exp","idx","postMessage","modifiedBuffer"],"sourceRoot":""}